export { createHttpResponseObject }
export type { HttpResponse }

import {
  getStreamReadableNode,
  getStreamReadableWeb,
  pipeToStreamWritableWeb,
  pipeToStreamWritableNode,
  StreamPipeNode,
  StreamPipeWeb,
  StreamReadableNode,
  StreamReadableWeb,
  StreamWritableNode,
  StreamWritableWeb,
  isStream,
  getStreamName,
  inferStreamName,
  isStreamWritableWeb,
  isStreamWritableNode
} from '../html/stream'
import { inferEarlyHintLink } from '../html/injectAssets/inferHtmlTags'
import type { PageAsset, GetPageAssets } from './getPageAssets'
import { assert, assertUsage, assertWarning } from '../../utils'
import { isErrorPageId } from '../../../shared/route'
import { getHtmlString, type HtmlRender } from '../html/renderHtml'

type StatusCode = 200 | 404 | 500
type ContentType = 'application/json' | 'text/html;charset=utf-8'
type EarlyHint = PageAsset & {
  earlyHintLink: string
}
type HttpResponse = {
  statusCode: StatusCode
  contentType: ContentType
  body: string
  getBody: () => Promise<string>
  getReadableWebStream: () => StreamReadableWeb
  pipe: (writable: StreamWritableWeb | StreamWritableNode) => void
  earlyHints: EarlyHint[]
  /** @deprecated */
  getNodeStream: () => Promise<StreamReadableNode>
  /** @deprecated */
  getWebStream: () => StreamReadableWeb
  /** @deprecated */
  pipeToNodeWritable: StreamPipeNode
  /** @deprecated */
  pipeToWebWritable: StreamPipeWeb
}
async function createHttpResponseObject(
  htmlRender: null | HtmlRender,
  renderFilePath: null | string,
  pageContext: {
    _isPageContextRequest: boolean
    _pageId: null | string
    is404: null | boolean
    errorWhileRendering: null | Error
    __getPageAssets: GetPageAssets
  }
): Promise<HttpResponse | null> {
  if (htmlRender === null) {
    return null
  }

  let statusCode: StatusCode
  {
    const isError = !pageContext._pageId || isErrorPageId(pageContext._pageId)
    if (pageContext.errorWhileRendering) {
      assert(isError)
    }
    if (!isError) {
      assert(pageContext.is404 === null)
      statusCode = 200
    } else {
      assert(pageContext.is404 === true || pageContext.is404 === false)
      statusCode = pageContext.is404 ? 404 : 500
    }
  }

  // The `.pageContext.json` HTTP request's body is generated by `@brillout/json-serializer` thus always a string
  assert(!pageContext._isPageContextRequest || typeof htmlRender === 'string')

  const streamDocs = 'See https://vite-plugin-ssr.com/stream for more information.'

  const earlyHints: EarlyHint[] = (await pageContext.__getPageAssets()).map((asset) => ({
    ...asset,
    earlyHintLink: inferEarlyHintLink(asset)
  }))

  return {
    statusCode,
    contentType: pageContext._isPageContextRequest ? 'application/json' : 'text/html;charset=utf-8',
    earlyHints,
    get body() {
      if (typeof htmlRender !== 'string') {
        assert(renderFilePath)
        assertUsage(
          false,
          errMsg('body', 'Use `pageContext.httpResponse.pipe()` or `pageContext.httpResponse.getBody()` instead')
        )
      }
      const body = htmlRender
      return body
    },
    async getBody(): Promise<string> {
      const body = await getHtmlString(htmlRender)
      return body
    },
    async getNodeStream() {
      assertWarning(
        false,
        '`pageContext.httpResponse.getNodeStream()` is outdated, use `pageContext.httpResponse.pipe()` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const nodeStream = await getStreamReadableNode(htmlRender)
      assertUsage(nodeStream !== null, errMsg('getNodeStream()', fixMsg('readable', 'node')))
      return nodeStream
    },
    getWebStream() {
      assertWarning(
        false,
        '`pageContext.httpResponse.getWebStream(res)` is outdated, use `pageContext.httpResponse.getReadableWebStream(res)` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const webStream = getStreamReadableWeb(htmlRender)
      assertUsage(webStream !== null, errMsg('getWebStream()', fixMsg('readable', 'web')))
      return webStream
    },
    getReadableWebStream() {
      const webStream = getStreamReadableWeb(htmlRender)
      assertUsage(webStream !== null, errMsg('getReadableWebStream()', fixMsg('readable', 'web')))
      return webStream
    },
    pipeToWebWritable(writable: StreamWritableWeb) {
      assertWarning(
        false,
        '`pageContext.httpResponse.pipeToWebWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const success = pipeToStreamWritableWeb(htmlRender, writable)
      assertUsage(success, errMsg('pipeToWebWritable()'))
    },
    pipeToNodeWritable(writable: StreamWritableNode) {
      assertWarning(
        false,
        '`pageContext.httpResponse.pipeToNodeWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const success = pipeToStreamWritableNode(htmlRender, writable)
      assertUsage(success, errMsg('pipeToNodeWritable()'))
    },
    pipe(writable: StreamWritableNode | StreamWritableWeb) {
      if (isStreamWritableWeb(writable)) {
        const success = pipeToStreamWritableWeb(htmlRender, writable)
        assertUsage(success, errMsg('pipe()'))
        return
      }
      if (isStreamWritableNode(writable)) {
        const success = pipeToStreamWritableNode(htmlRender, writable)
        assertUsage(success, errMsg('pipe()'))
        return
      }
      assertUsage(
        false,
        `The argument \`writable\` passed to \`pageContext.httpResponse.pipe(writable)\` doesn't seem to be ${getStreamName(
          'writable',
          'web'
        )} nor ${getStreamName('writable', 'node')}.`
      )
    }
  }

  function errMsg(method: string, fixMsg?: string) {
    let htmlRenderName: string
    if (typeof htmlRender === 'string') {
      htmlRenderName = 'an HTML string'
    } else if (isStream(htmlRender)) {
      htmlRenderName = inferStreamName(htmlRender)
    } else {
      assert(false)
    }
    assert(['a ', 'an ', 'the '].some((s) => htmlRenderName.startsWith(s)))
    assert(!fixMsg || !fixMsg.endsWith('.'))
    return [
      `\`pageContext.httpResponse.${method}\` can't be used because your \`render()\` hook (${renderFilePath}) provides ${htmlRenderName}`,
      fixMsg,
      streamDocs
    ]
      .filter(Boolean)
      .join('. ')
  }
  function fixMsg(type: 'pipe' | 'readable', standard: 'web' | 'node') {
    const streamName = getStreamName(type, standard)
    assert(['a ', 'an ', 'the '].some((s) => streamName.startsWith(s)))
    return `Make sure your \`render()\` hook provides ${streamName} instead`
  }
}
